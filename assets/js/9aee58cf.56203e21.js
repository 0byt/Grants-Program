"use strict";(self.webpackChunkgrants=self.webpackChunkgrants||[]).push([[70869],{51315:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var n=a(87462),i=(a(67294),a(3905));a(8209);const r={},o="CILA - Omnichain Infrastructure",l={unversionedId:"applications/CILA-omnichain-infrastructure",id:"applications/CILA-omnichain-infrastructure",title:"CILA - Omnichain Infrastructure",description:"- Team Name: Collective Intelligence Labs",source:"@site/applications/CILA-omnichain-infrastructure.md",sourceDirName:"applications",slug:"/applications/CILA-omnichain-infrastructure",permalink:"/applications/CILA-omnichain-infrastructure",draft:!1,editUrl:"https://github.com/w3f/Grants-Program/edit/master/applications/CILA-omnichain-infrastructure.md",tags:[],version:"current",frontMatter:{}},s={},d=[{value:"Project Overview \ud83d\udcc4",id:"project-overview-",level:2},{value:"Overview",id:"overview",level:3},{value:"Introduction",id:"introduction",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Protobuf support on-chain",id:"protobuf-support-on-chain",level:4},{value:"Aggregate Repository",id:"aggregate-repository",level:4},{value:"Event Store",id:"event-store",level:4},{value:"Command/operations Dispatcher",id:"commandoperations-dispatcher",level:4},{value:"Events Emitter",id:"events-emitter",level:4},{value:"Conclusion",id:"conclusion",level:2},{value:"\ud83d\ude80 Technology Stack",id:"-technology-stack",level:2},{value:"Usage",id:"usage",level:2},{value:"Benefits",id:"benefits",level:2},{value:"Conclusion",id:"conclusion-1",level:2},{value:"Description",id:"description",level:2},{value:"Implementation",id:"implementation-1",level:2},{value:"Features",id:"features",level:2},{value:"Benefits",id:"benefits-1",level:2},{value:"Conclusion",id:"conclusion-2",level:2},{value:"Overview",id:"overview-1",level:2},{value:"Implementation",id:"implementation-2",level:2},{value:"Conclusion",id:"conclusion-3",level:2},{value:"Description",id:"description-1",level:2},{value:"Implementation",id:"implementation-3",level:2},{value:"Internal state",id:"internal-state",level:3},{value:"Command handling",id:"command-handling",level:3},{value:"Event sourcing",id:"event-sourcing",level:3},{value:"Snapshotting",id:"snapshotting",level:3},{value:"Conclusion",id:"conclusion-4",level:2},{value:"Properties",id:"properties",level:3},{value:"Methods",id:"methods",level:3},{value:"Usage",id:"usage-1",level:3},{value:"Diagramm",id:"diagramm",level:2},{value:"Domain",id:"domain",level:2},{value:"Aggregate",id:"aggregate-1",level:3},{value:"<code>AggregateState</code>",id:"aggregatestate-1",level:4},{value:"Methods",id:"methods-1",level:5},{value:"<code>DomainEvent</code>",id:"domainevent",level:4},{value:"Methods",id:"methods-2",level:5},{value:"<code>DomainEventType</code>",id:"domaineventtype",level:4},{value:"Variants",id:"variants",level:5},{value:"Entities",id:"entities",level:3},{value:"<code>NFT</code>",id:"nft",level:4},{value:"Fields",id:"fields",level:5},{value:"Methods",id:"methods-3",level:5},{value:"Application",id:"application",level:2},{value:"Command",id:"command",level:3},{value:"<code>Command</code>",id:"command-1",level:4},{value:"Fields",id:"fields-1",level:5},{value:"Methods",id:"methods-4",level:5},{value:"<code>CommandType</code>",id:"commandtype",level:4},{value:"Variants",id:"variants-1",level:5},{value:"Service",id:"service",level:3},{value:"<code>CommandDispatcher</code>",id:"commanddispatcher",level:4},{value:"Methods",id:"methods-5",level:5},{value:"<code>NFTService</code>",id:"nftservice",level:4},{value:"Fields",id:"fields-2",level:5},{value:"Methods",id:"methods-6",level:5},{value:"Event",id:"event",level:3},{value:"<code>DomainEventType</code>",id:"domaineventtype-1",level:4},{value:"Variants",id:"variants-2",level:5},{value:"<code>DomainEvent</code>",id:"domainevent-1",level:4},{value:"Fields",id:"fields-3",level:5},{value:"Methods",id:"methods-7",level:5},{value:"Store",id:"store",level:3},{value:"<code>AggregateRepository</code>",id:"aggregaterepository",level:4},{value:"Fields",id:"fields-4",level:5},{value:"Methods",id:"methods-8",level:5},{value:"Team \ud83e\uddbe",id:"team-",level:2},{value:"Team members",id:"team-members",level:3},{value:"Contact",id:"contact",level:3},{value:"Legal Structure",id:"legal-structure",level:3},{value:"Team&#39;s experience",id:"teams-experience",level:3},{value:"Team Code Repos",id:"team-code-repos",level:3},{value:"Team GitHub Profiles",id:"team-github-profiles",level:3},{value:"Team LinkedIn Profiles",id:"team-linkedin-profiles",level:3},{value:"Development Status \ud83d\udcd6",id:"development-status-",level:2},{value:"Development Roadmap \ud83d\udd29",id:"development-roadmap-",level:2},{value:"Overview",id:"overview-2",level:3},{value:"Milestone 1 \u2014 Design and Implementation",id:"milestone-1--design-and-implementation",level:3},{value:"Milestone 2 \u2014 Testing and Documentation",id:"milestone-2--testing-and-documentation",level:3},{value:"Milestone 3 \u2014 Example Smart Contracts and Enhancements",id:"milestone-3--example-smart-contracts-and-enhancements",level:3},{value:"Future Plans",id:"future-plans",level:2},{value:"Additional Information \u2795",id:"additional-information-",level:2}],p={toc:d},m="wrapper";function c(e){let{components:t,...a}=e;return(0,i.kt)(m,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"cila---omnichain-infrastructure"},"CILA - Omnichain Infrastructure"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Team Name:")," Collective Intelligence Labs"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Payment Address:"),"  bc1qff0kjc6pyjkneyt3pctm5nahjpd9f774avz55x (BTC)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Level:")," 2"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Status:")," ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/w3f/Grants-Program/pull/1679#issuecomment-1823419675"},"Terminated"))),(0,i.kt)("h2",{id:"project-overview-"},"Project Overview \ud83d\udcc4"),(0,i.kt)("h3",{id:"overview"},"Overview"),(0,i.kt)("p",null,"The goal of this project is to implement an omnichain smart contract infrastructure support for Substrate framework. \ud83c\udf10\ud83e\udd16 This will include the implementation of CQRS + Event Sourcing execution environment plus an example smart-contract. The implementation will be done using WASM and/or native Rust Substrate implementation as a pallet. The implementation will include implementing Protobuf support on-chain, serialization/deserialization, aggregated repository, event store, command/operations dispatcher, and events emitter. \ud83d\udee0\ufe0f\ud83d\udc68\u200d\ud83d\udcbb"),(0,i.kt)("h3",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"This project aims to add an omnichain smart contract infrastructure support for Substrate framework by implementing a CQRS + Event Sourcing execution environment. CQRS (Command Query Responsibility Segregation) is a design pattern that separates the command and query responsibilities of an application. Event Sourcing is a design pattern that represents the state of an application as a series of events that are stored in an event store. \ud83e\uddec\ud83d\udcbb"),(0,i.kt)("h3",{id:"implementation"},"Implementation"),(0,i.kt)("p",null,"The implementation of the omnichain smart contract infrastructure will be done using WASM and/or native Rust Substrate implementation as a pallet. The implementation will include the following components:"),(0,i.kt)("h4",{id:"protobuf-support-on-chain"},"Protobuf support on-chain"),(0,i.kt)("p",null,"Protobuf is a language-agnostic binary serialization format that allows developers to define structured data schemas. The implementation will include support for Protobuf on-chain, which will enable developers to define smart contract interfaces using Protobuf. \ud83e\udd16\ud83d\udcbe"),(0,i.kt)("h4",{id:"aggregate-repository"},"Aggregate Repository"),(0,i.kt)("p",null,"Aggregate Repository is a data storage module that manages the state and storage of aggregate objects. It provides methods for creating, reading, updating, and deleting aggregates. \ud83d\udcc8\ud83d\udcca"),(0,i.kt)("h4",{id:"event-store"},"Event Store"),(0,i.kt)("p",null,"An event store is a database that stores events in the order they occurred. The implementation will include an event store, which will store all the events generated by the smart contract. \ud83d\uddc2\ufe0f\ud83d\udcd1"),(0,i.kt)("h4",{id:"commandoperations-dispatcher"},"Command/operations Dispatcher"),(0,i.kt)("p",null,"A command/operations dispatcher is a component that receives commands/operations and dispatches them to the appropriate handler. The implementation will include a command/operations dispatcher, which will enable developers to define command/operation handlers for the smart contract. \ud83d\ude9a\ud83d\udc68\u200d\u2708\ufe0f"),(0,i.kt)("h4",{id:"events-emitter"},"Events Emitter"),(0,i.kt)("p",null,"An events emitter is a component that emits events. The implementation will include an events emitter, which will enable developers to define event handlers for the smart contract. \ud83d\udce3\ud83d\udd0a"),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"The completion of this project will provide a powerful infrastructure for developers to build customized omnichain smart contracts on the Substrate framework. \ud83d\udcaa\ud83d\udc68\u200d\ud83d\udcbc"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/QsmzpZR.png",alt:"architecture"})),(0,i.kt)("h2",{id:"-technology-stack"},"\ud83d\ude80 Technology Stack"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Programming Language")," - Rust \ud83e\udd80"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Blockchain Framework")," - Substrate \u26d3\ufe0f"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Virtual Machine")," - WebAssembly (WASM) \ud83d\udd78\ufe0f"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Serialization")," - Protocol Buffers (protobuf) \ud83d\udcdc: a language-agnostic data serialization format that allows for efficient and interoperable communication between different services and systems."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Design Patterns"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Event Sourcing \ud83d\udcdd: a pattern that captures all changes to an application state as a sequence of events, which can be used to reconstruct the state at any point in time."),(0,i.kt)("li",{parentName:"ul"},"Command Query Responsibility Segregation (CQRS) \ud83e\uddec: a pattern that separates the read and write concerns of an application, using separate models and interfaces for each."),(0,i.kt)("li",{parentName:"ul"},"Saga pattern \ud83c\udf1f: a pattern for coordinating distributed transactions across multiple services, ensuring consistency and reliability."),(0,i.kt)("li",{parentName:"ul"},"Domain-Driven Design (DDD) \ud83c\udff0: a design approach that emphasizes the importance of the domain model in shaping the architecture of a software system.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Database")," - MongoDB \ud83d\uddc4\ufe0f: a NoSQL document database that provides scalability, flexibility, and high availability."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Testing Framework")," - Rust Testing \ud83e\uddea: Rust has an inbuilt testing framework that enables testing of units of code in isolation."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"CI/CD")," - GitHub Actions \ud83d\ude80: a continuous integration and continuous deployment service that can automate the build and deployment processes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Containerization")," - Docker \ud83d\udc33: a tool that allows for the creation, deployment, and running of applications in containers, providing a consistent runtime environment across different platforms."),(0,i.kt)("h1",{id:"documentation-for-core-copmpontents"},"Documentation for Core Copmpontents"),(0,i.kt)("h1",{id:"dispatcher"},"Dispatcher"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Dispatcher")," is a component of the omnichain smart contract infrastructure that receives commands/operations and dispatches them to the appropriate handler. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Dispatcher")," class enables developers to define command/operation handlers for the smart contract."),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Dispatcher")," can be used in the implementation of the CQRS + Event Sourcing execution environment for Substrate framework. It receives commands/operations from external sources, such as a client or a node, and routes them to the appropriate command/operation handler."),(0,i.kt)("p",null,"To use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Dispatcher"),", developers first define a set of command/operation handlers for the smart contract. These handlers can be implemented as methods in a Rust struct. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Dispatcher")," class then instantiates this struct and routes commands/operations to the appropriate method based on the type of command/operation."),(0,i.kt)("h2",{id:"benefits"},"Benefits"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Dispatcher")," provides a simple and flexible way to handle commands/operations in the smart contract. By defining a set of command/operation handlers, developers can easily add new functionality to the smart contract without having to modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"Dispatcher")," class itself."),(0,i.kt)("p",null,"In addition, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Dispatcher")," enables developers to implement complex business logic in the smart contract by routing commands/operations to the appropriate handler. This allows for a more modular and maintainable codebase."),(0,i.kt)("h2",{id:"conclusion-1"},"Conclusion"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Dispatcher")," is a crucial component of the omnichain smart contract infrastructure. By enabling developers to define command/operation handlers for the smart contract, it provides a simple and flexible way to handle commands/operations. Its usage in the implementation of the CQRS + Event Sourcing execution environment for Substrate framework enables developers to implement complex business logic in a modular and maintainable codebase."),(0,i.kt)("h1",{id:"eventstore"},"EventStore"),(0,i.kt)("h2",{id:"description"},"Description"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore"),"  is a database that stores events in the order they occurred. It is a crucial component of the omnichain smart contract infrastructure support for Substrate framework. The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," class enables the storage of all events generated by the smart contract, allowing for a complete historical record of all transactions and changes to the smart contract's state."),(0,i.kt)("h2",{id:"implementation-1"},"Implementation"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore"),"  is implemented using an internal Substrate database. The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," stores events in the form of serialized binary data plus metadata, which can be easily deserialized for querying and analysis."),(0,i.kt)("h2",{id:"features"},"Features"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore"),"  includes the following features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Event storage:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," stores all events generated by the smart contract in the order they occurred, allowing for a complete historical record of all transactions and changes to the smart contract's state.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Querying:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," allows for easy querying of events using various criteria, such as time range, event type, or specific parameters.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Deserialization:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," can easily deserialize stored binary data for querying and analysis.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Scalability:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore"),"  can handle large volumes of events and is designed for scalability."))),(0,i.kt)("h2",{id:"benefits-1"},"Benefits"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," provides several benefits to developers building smart contracts on the Substrate framework, including:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Transparency:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," provides a complete historical record of all transactions and changes to the smart contract's state, ensuring transparency and accountability.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Auditability:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," allows for easy querying and analysis of events, enabling developers to audit the smart contract's behavior and ensure compliance with regulations and business rules.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Flexibility:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," can handle a wide range of event types and is designed for scalability, providing flexibility for developers building smart contracts on the Substrate framework."))),(0,i.kt)("h2",{id:"conclusion-2"},"Conclusion"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," is a crucial component of the omnichain smart contract infrastructure support for Substrate framework. It provides event storage, querying, deserialization, and scalability features, enabling developers to build transparent, auditable, and flexible smart contracts on the Substrate framework. The completion of this project will provide a powerful infrastructure for developers to build customized smart contracts on the Substrate framework, with the ",(0,i.kt)("inlineCode",{parentName:"p"},"EventStore")," serving as a key component of this infrastructure."),(0,i.kt)("h1",{id:"snapshot-store"},"Snapshot Store"),(0,i.kt)("h2",{id:"overview-1"},"Overview"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot Store")," is a component of the omnichain smart contract infrastructure that provides a way to store and retrieve snapshots of the smart contract state. A snapshot is a read-only view of the smart contract state at a particular point in time. Snapshots are useful for optimizing the performance of the smart contract by reducing the amount of data that needs to be read from the event store."),(0,i.kt)("h2",{id:"implementation-2"},"Implementation"),(0,i.kt)("p",null,"The implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot Store")," includes the following components:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Snapshot Store"),": The Snapshot Store is the primary component. It provides an interface for storing and retrieving snapshots of the smart contract state."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Snapshot Index"),": The Snapshot Index is a data structure that is used to index snapshots by their version. It allows for efficient retrieval of the latest snapshot."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Snapshot Writer"),": The Snapshot Writer is a component that is used to write snapshots to the Snapshot Store. It receives the current state of the smart contract and writes it to the Snapshot Store as a snapshot."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Snapshot Reader"),": The Snapshot Reader is a component that is used to read snapshots from the Snapshot Store. It receives a snapshot version and returns a read-only view of the smart contract state at that version.")),(0,i.kt)("h2",{id:"conclusion-3"},"Conclusion"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot Store")," provides a way to store and retrieve snapshots of the smart contract state, which can be used to optimize the performance of the smart contract. The implementation includes the ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot Store"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot Index"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot Writer"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Snapshot Reader")," components. The completion of this component will provide a pefrormance optmization for omnichain smart contracts on the Substrate framework."),(0,i.kt)("h1",{id:"aggregate"},"Aggregate"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," is a core component of the CQRS + Event Sourcing design pattern. It represents the current state of an entity and is responsible for handling commands and producing events."),(0,i.kt)("h2",{id:"description-1"},"Description"),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," is a stateful object that represents a single entity in the system. It maintains its state by applying events to its internal state. A new state can be generated by applying new events to the existing state. "),(0,i.kt)("p",null,"In the context of the Substrate framework, an ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," is implemented as a Rust struct that contains its internal state and a set of methods to apply events and handle commands."),(0,i.kt)("h2",{id:"implementation-3"},"Implementation"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," is implemented using the following components:"),(0,i.kt)("h3",{id:"internal-state"},"Internal state"),(0,i.kt)("p",null,"The internal state of an ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," is represented as a Rust struct. The struct contains all the data necessary to represent the current state of the entity."),(0,i.kt)("h3",{id:"command-handling"},"Command handling"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," contains a set of methods to handle commands. These methods accept a command object as input and return a set of events that represent the result of executing the command."),(0,i.kt)("h3",{id:"event-sourcing"},"Event sourcing"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," implements event sourcing by maintaining a list of events that have been applied to the internal state. When a new command is received, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," applies the appropriate events to generate a new state."),(0,i.kt)("h3",{id:"snapshotting"},"Snapshotting"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," implements snapshotting by periodically storing a snapshot of its internal state. When an ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," is retrieved from its event stream, it can be initialized with the latest snapshot and then apply only the events that occurred after the snapshot."),(0,i.kt)("h2",{id:"conclusion-4"},"Conclusion"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," is a core component of the CQRS + Event Sourcing design pattern. It represents the current state of an entity and is responsible for handling commands and producing events. The implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate")," in the Substrate framework provides a powerful mechanism for building complex and scalable smart contracts."),(0,i.kt)("h1",{id:"aggregatestate"},"AggregateState"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"AggregateState")," represents the state of an aggregate object in the event sourcing pattern. It is responsible for maintaining the current state of the aggregate object by processing the events that have occurred in the past."),(0,i.kt)("h3",{id:"properties"},"Properties"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"id"),": The unique identifier of the aggregate object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"version"),": The version of the aggregate object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"events"),": The list of events that have occurred in the past.")),(0,i.kt)("h3",{id:"methods"},"Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"apply_event(event)"),": Applies the given event to the current state of the aggregate object. This method updates the state of the aggregate object based on the event that occurred."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get_version()"),": Returns the version of the aggregate object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get_events()"),": Returns the list of events that have occurred in the past.")),(0,i.kt)("h3",{id:"usage-1"},"Usage"),(0,i.kt)("p",null,"To use the ",(0,i.kt)("inlineCode",{parentName:"p"},"AggregateState")," , you must first create an instance of it and initialize it with the current state of the aggregate object. You can then apply events to the aggregate object by calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"apply_event()")," method."),(0,i.kt)("h2",{id:"diagramm"},"Diagramm"),(0,i.kt)("p",null,"Architecture Overview Diagram\n",(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/nWGtuEc.png",alt:"Diagramm"})),(0,i.kt)("p",null,"Flow Diagramm"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/1jeLNo1.png",alt:"Diagramm"})),(0,i.kt)("p",null,"Command Processing Flow Diagramm"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"}," +------------+       +------------+       +-----------------+       +-------------------+       +------------+\n | Application|       |   Router   |       | Execution Chain |       |  Event Relay Node |       | Aggregation|\n +------------+       +------------+       +-----------------+       +-------------------+       +------------+\n        |                    |                    |                            |                               |\n        |   Command Request  |                    |                            |                               |\n        |------------------\x3e|                    |                            |                               |\n        |                    |                    |                            |                               |\n        |   Command Handler  |                    |                            |                               |\n        |------------------\x3e|                    |                            |                               |\n        |                    |   Command Request   |                            |                               |\n        |                    |-------------------\x3e|                            |                               |\n        |                    |                    |  Execute Command (CQRS)    |                               |\n        |                    |                    |---------------------------\x3e|                               |\n        |                    |                    |                            |     Store Event (ES)         |\n        |                    |                    |                            |-----------------------------\x3e|\n        |                    |                    |                            |                               |\n        |                    |                    |                            |   Broadcast Event to        |\n        |                    |                    |                            |     Other Chains            |\n        |                    |                    |                            |---------------------------\x3e|\n        |                    |                    |                            |                               |\n        |                    |                    |                            |  Transmit Event to          |\n        |                    |                    |                            |     Aggregation Cluster     |\n        |                    |                    |                            |-----------------------------\x3e|\n        |                    |                    |                            |                               |\n        |                    |                    |                            |   Process Events and        |\n        |                    |                    |                            |     Produce Aggregated Data |\n        |                    |                    |                            |<-----------------------------|\n        |                    |                    |                            |                               |\n        |                    |                    |                            |     Return Aggregated Data  |\n        |                    |                    |                            |<-----------------------------|\n        |                    |                    |                            |                               |\n\n")),(0,i.kt)("h1",{id:"api-documentation"},"API Documentation"),(0,i.kt)("h2",{id:"domain"},"Domain"),(0,i.kt)("h3",{id:"aggregate-1"},"Aggregate"),(0,i.kt)("h4",{id:"aggregatestate-1"},(0,i.kt)("inlineCode",{parentName:"h4"},"AggregateState")),(0,i.kt)("h5",{id:"methods-1"},"Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"new() -> Self"),": Creates a new instance of ",(0,i.kt)("inlineCode",{parentName:"li"},"AggregateState"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"apply_events(&mut self, events: Vec<DomainEvent>) -> Result<(), String>"),": Applies a list of domain events to the aggregate state."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"clear(&mut self)"),": Clears the state of the aggregate.")),(0,i.kt)("h4",{id:"domainevent"},(0,i.kt)("inlineCode",{parentName:"h4"},"DomainEvent")),(0,i.kt)("h5",{id:"methods-2"},"Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"new(evnt_type: DomainEventType, evnt_payload: Vec<u8>) -> Self"),": Creates a new instance of ",(0,i.kt)("inlineCode",{parentName:"li"},"DomainEvent"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"serialize(&self) -> Result<Vec<u8>, String>"),": Serializes the domain event to a byte array.")),(0,i.kt)("h4",{id:"domaineventtype"},(0,i.kt)("inlineCode",{parentName:"h4"},"DomainEventType")),(0,i.kt)("h5",{id:"variants"},"Variants"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NFT_MINTED")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NFT_TRANSFERED"))),(0,i.kt)("h3",{id:"entities"},"Entities"),(0,i.kt)("h4",{id:"nft"},(0,i.kt)("inlineCode",{parentName:"h4"},"NFT")),(0,i.kt)("h5",{id:"fields"},"Fields"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hash: [u8; 32]"),": The unique hash of the NFT."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"owner: Address"),": The address of the owner of the NFT.")),(0,i.kt)("h5",{id:"methods-3"},"Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"new(hash: [u8; 32], owner: Address) -> Self"),": Creates a new instance of ",(0,i.kt)("inlineCode",{parentName:"li"},"NFT"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get_hash(&self) -> [u8; 32]"),": Returns the hash of the NFT."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get_owner(&self) -> Address"),": Returns the owner of the NFT."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"transfer(&mut self, new_owner: Address)"),": Transfers the ownership of the NFT to a new owner.")),(0,i.kt)("h2",{id:"application"},"Application"),(0,i.kt)("h3",{id:"command"},"Command"),(0,i.kt)("h4",{id:"command-1"},(0,i.kt)("inlineCode",{parentName:"h4"},"Command")),(0,i.kt)("h5",{id:"fields-1"},"Fields"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cmd_type: CommandType")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cmd_payload: Vec<u8>"))),(0,i.kt)("h5",{id:"methods-4"},"Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"new(cmd_type: CommandType, cmd_payload: Vec<u8>) -> Self"),": Creates a new instance of ",(0,i.kt)("inlineCode",{parentName:"li"},"Command"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"serialize(&self) -> Result<Vec<u8>, String>"),": Serializes the command to a byte array.")),(0,i.kt)("h4",{id:"commandtype"},(0,i.kt)("inlineCode",{parentName:"h4"},"CommandType")),(0,i.kt)("h5",{id:"variants-1"},"Variants"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MINT_NFT")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TRANSFER_NFT"))),(0,i.kt)("h3",{id:"service"},"Service"),(0,i.kt)("h4",{id:"commanddispatcher"},(0,i.kt)("inlineCode",{parentName:"h4"},"CommandDispatcher")),(0,i.kt)("h5",{id:"methods-5"},"Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dispatch(command: Command) -> Result<(), String>"),": Dispatches a command to the appropriate handler.")),(0,i.kt)("h4",{id:"nftservice"},(0,i.kt)("inlineCode",{parentName:"h4"},"NFTService")),(0,i.kt)("h5",{id:"fields-2"},"Fields"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state: NFTsState")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"event_store: Box<dyn EventStore>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dispatcher: Box<dyn CommandDispatcher>"))),(0,i.kt)("h5",{id:"methods-6"},"Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"new(state: NFTsState, event_store: Box<dyn EventStore>, dispatcher: Box<dyn CommandDispatcher>) -> Self"),": Creates a new instance of ",(0,i.kt)("inlineCode",{parentName:"li"},"NFTService"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"handle_command(&mut self, command: Command) -> Result<(), String>"),": Handles a command by dispatching it to the appropriate handler."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get_nft_owner(&self, hash: [u8; 32]) -> Option<Address>"),": Returns the owner of an NFT with the given hash.")),(0,i.kt)("h3",{id:"event"},"Event"),(0,i.kt)("h4",{id:"domaineventtype-1"},(0,i.kt)("inlineCode",{parentName:"h4"},"DomainEventType")),(0,i.kt)("h5",{id:"variants-2"},"Variants"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NFT_MINTED")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NFT_TRANSFERED"))),(0,i.kt)("h4",{id:"domainevent-1"},(0,i.kt)("inlineCode",{parentName:"h4"},"DomainEvent")),(0,i.kt)("h5",{id:"fields-3"},"Fields"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"evnt_type: DomainEventType")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"evnt_payload: Vec<u8>"))),(0,i.kt)("h5",{id:"methods-7"},"Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"new(evnt_type: DomainEventType, evnt_payload: Vec<u8>) -> Self"),": Creates a new instance of ",(0,i.kt)("inlineCode",{parentName:"li"},"DomainEvent"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"serialize(&self) -> Result<Vec<u8>, String>"),": Serializes the domain event to a byte array.")),(0,i.kt)("h3",{id:"store"},"Store"),(0,i.kt)("h4",{id:"aggregaterepository"},(0,i.kt)("inlineCode",{parentName:"h4"},"AggregateRepository")),(0,i.kt)("h5",{id:"fields-4"},"Fields"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"event_store: Box<dyn EventStore>"))),(0,i.kt)("h5",{id:"methods-8"},"Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"new(event_store: Box<dyn EventStore>) -> Self"),": Creates a new instance of `AggregateRepository")),(0,i.kt)("p",null,"\ud83c\udf1f ",(0,i.kt)("strong",{parentName:"p"},"Ecosystem Fit:")," \ud83c\udf1f"),(0,i.kt)("p",null,"\ud83d\udd39 ",(0,i.kt)("strong",{parentName:"p"},"Project's Fit:")," CILA will provide an infrastructure for building efficient omnichain smart contracts that can be integrated into the Polkadot ecosystem, offering a unique solution in the Substrate/Polkadot/Kusama landscape."),(0,i.kt)("p",null,"\ud83d\udd39 ",(0,i.kt)("strong",{parentName:"p"},"Target Audience:")," Developers interested in building omnichain smart contracts on Substrate, Polkadot, and Kusama, particularly those looking to develop cross-chain applications and interact with multiple blockchain networks."),(0,i.kt)("p",null,"\ud83d\udd39 ",(0,i.kt)("strong",{parentName:"p"},"Project's Purpose:")," The infrastructure will enable developers to build more efficient and scalable omnichain smart contracts, making it easier to create cross-chain applications that interact with multiple blockchain networks. This will help solve the problem of siloed blockchains and allow developers to take advantage of the benefits of multiple chains."),(0,i.kt)("p",null,"\ud83d\udd39 ",(0,i.kt)("strong",{parentName:"p"},"Similar Projects:")," We are not aware of any other projects similar to OmniChain in the Substrate/Polkadot/Kusama ecosystem, offering a unique solution for building omnichain smart contracts. "),(0,i.kt)("h2",{id:"team-"},"Team \ud83e\uddbe"),(0,i.kt)("h3",{id:"team-members"},"Team members"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\ud83d\udc68\u200d\ud83d\udcbb Alex Shkor - Architect, Developer, Team Lead"),(0,i.kt)("li",{parentName:"ul"},"\ud83d\udc68\u200d\ud83d\udcbb Alexey Kulik - Architect, Developer"),(0,i.kt)("li",{parentName:"ul"},"\ud83d\udc69\u200d\ud83d\udcbc Julia Shinkevich - Project Manager"),(0,i.kt)("li",{parentName:"ul"},"\ud83e\uddd1\u200d\ud83d\udcbc Max Slyzkoukh - Product Manager"),(0,i.kt)("li",{parentName:"ul"},"\ud83d\udc68\u200d\ud83d\udd27 Yahor Tsaryk - Engineer")),(0,i.kt)("h3",{id:"contact"},"Contact"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Contact Name:")," Alex Shkor"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Contact Email:")," ",(0,i.kt)("a",{parentName:"li",href:"mailto:alex@cilabs.ai"},"alex@cilabs.ai")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Website:")," ",(0,i.kt)("a",{parentName:"li",href:"https://collectiveintelligence.dev/"},"https://collectiveintelligence.dev/"))),(0,i.kt)("h3",{id:"legal-structure"},"Legal Structure"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Registered Address:")," 16192 Coastal Highway, Lewes, DE 19958, United States."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Registered Legal Entity:")," Collective Intelligence Labs Inc.")),(0,i.kt)("h3",{id:"teams-experience"},"Team's experience"),(0,i.kt)("p",null,"Our team's extensive experience in blockchain development and past successful projects make us well-suited for this project. We have developed several blockchain-based platforms, including DeSci, which offers a decentralized scientific communication infrastructure, and IPledger, which registers intellectual property assets on the blockchain. We have also built a Proof of Share protocol for verification on a chain that specific files have been shared between parties, an on-chain grants distribution platform, a decentralized technology transfer platform, ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/DEIPworld/deip-node/tree/develop/pallets/deip_f_nft"},"F-NFT")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/DEIPworld/deip-node/tree/develop/event-proxy"},"Event Proxy")," for Substrate, and other projects."),(0,i.kt)("p",null,"Our team members have also contributed to open-source blockchain projects, demonstrating our commitment to the development of the blockchain ecosystem as a whole."),(0,i.kt)("p",null,"Our Team Lead is distributed systems architect and has over 14 years of experience in this field, with one of our team members being the inventor of omnichain smart-contracts protocol, which is an important aspect of this project. Our Software Engineer has over 10 years of experience in distributed systems engineering and was the ex-CTO at DEIP and the creator of the Economy Protocol. Our Tech Lead has experience in distributed system and blockchain R&D and was the ex-Head of R&D at Paralect, while also having experience as an ex-CPO at DEIP. Our Head of Marketing has 9 years of experience in PR and communications, having worked with micromobility and web3 startups. Our Product Manager expert in digital transformation has 6 years of experience in the procurement of 50+ leading private and state Ukrainian enterprises."),(0,i.kt)("p",null,"As a team, we have previously applied for a grant from the web3 foundation grants program for our DEIP project (DEIPWORLC Inc. legal entity). However, due to the constantly evolving market landscape and changing needs of the industry, we decided to pivot multiple times, and therefore did not deliver original proposal fully (only about 50% of it - onchain part). During the process we realized that on-chain IP management would not be possible without other infrastructure part. Therefore we decided to completely stop ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/DEIPworld"},"previous project"),", change our focus and start working on a diferent solution, the core solution that will make possible to implement DEIP and other our projects that rely on omni-chain infrastructure and onchain IP management - omni-chain infrastructure"),(0,i.kt)("p",null,"We believe that being transparent about our previous application and pivot is important. We want to assure the committee that we are committed to delivering the proposed solution for our current application, and that we are passionate about creating value in the blockchain ecosystem."),(0,i.kt)("p",null,"We are confident that our team's expertise and experience in developing distributed systems and infrastructure will enable us to successfully execute our proposed CILA omnichain infrastructure project. We believe that this infrastructure is crucial for the growth and adoption of blockchain technology, and we are excited about the opportunity to contribute to this space. "),(0,i.kt)("h3",{id:"team-code-repos"},"Team Code Repos"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Collective-Intelligence-Labs"},"https://github.com/Collective-Intelligence-Labs"))),(0,i.kt)("h3",{id:"team-github-profiles"},"Team GitHub Profiles"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/alexshkor"},"https://github.com/alexshkor")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aliakseikulik"},"https://github.com/aliakseikulik")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/yahortsaryk"},"https://github.com/yahortsaryk")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/juliacil"},"https://github.com/juliacil"))),(0,i.kt)("h3",{id:"team-linkedin-profiles"},"Team LinkedIn Profiles"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.linkedin.com/in/alexshkor/"},"https://www.linkedin.com/in/alexshkor/")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.linkedin.com/in/alexeykulik/"},"https://www.linkedin.com/in/alexeykulik/")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.linkedin.com/in/julia-shinkevich/"},"https://www.linkedin.com/in/julia-shinkevich/")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.linkedin.com/in/max-slyzkouh/"},"https://www.linkedin.com/in/max-slyzkouh/")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.linkedin.com/in/yahor-tsaryk-92032a68/"},"https://www.linkedin.com/in/yahor-tsaryk-92032a68/")," ")),(0,i.kt)("h2",{id:"development-status-"},"Development Status \ud83d\udcd6"),(0,i.kt)("p",null,"CILA omnichain infrastructure for Substrate is currently in the research and planning phase. We have conducted extensive research on the existing smart contract infrastructure and identified the need for an omnichain smart contract solution. Our team has also analyzed the capabilities of the Substrate/Polkadot/Kusama ecosystem and determined that it is the ideal platform for building this solution."),(0,i.kt)("p",null,"We have created a detailed project plan that outlines the development roadmap and milestones. This plan includes research and development of the necessary components."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Draft of solidity implementation: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/Collective-Intelligence-Labs/cila-sol-contracts"},"https://github.com/Collective-Intelligence-Labs/cila-sol-contracts")),(0,i.kt)("li",{parentName:"ul"},"Vision Paper: ",(0,i.kt)("a",{parentName:"li",href:"https://docsend.com/view/eqt2iazwmff3jikh"},"https://docsend.com/view/eqt2iazwmff3jikh"))),(0,i.kt)("h2",{id:"development-roadmap-"},"Development Roadmap \ud83d\udd29"),(0,i.kt)("h3",{id:"overview-2"},"Overview"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Total Estimated Duration:")," 3 months"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Full-Time Equivalent (FTE):")," 2 FTE"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Total Costs:")," 30,000 USD")),(0,i.kt)("h3",{id:"milestone-1--design-and-implementation"},"Milestone 1 \u2014 Design and Implementation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Estimated duration:")," 1 month"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"FTE:"),"  2"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Costs:")," 10,000 USD")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"right"},"Number"),(0,i.kt)("th",{parentName:"tr",align:null},"Deliverable"),(0,i.kt)("th",{parentName:"tr",align:null},"Specification"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0a.")),(0,i.kt)("td",{parentName:"tr",align:null},"License"),(0,i.kt)("td",{parentName:"tr",align:null},"Apache 2.0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0b.")),(0,i.kt)("td",{parentName:"tr",align:null},"Documentation"),(0,i.kt)("td",{parentName:"tr",align:null},"We will ensure comprehensive documentation of the code by providing both inline comments and a step-by-step tutorial. This tutorial will guide the user through spinning up a Substrate-based execution environment for the CILA Omnichain Infrastructure and testing omnichain transactions, showcasing the new functionality.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0c.")),(0,i.kt)("td",{parentName:"tr",align:null},"Testing and Testing Guide"),(0,i.kt)("td",{parentName:"tr",align:null},"We will conduct comprehensive unit testing on the core functionalities including Aggregate, Event Store, Aggregate Repository, Snapshot Store, and Dispatcher, to ensure optimum functionality and robustness. The testing guide will contain instructions on how to execute these tests.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0d.")),(0,i.kt)("td",{parentName:"tr",align:null},"Docker"),(0,i.kt)("td",{parentName:"tr",align:null},"We will deliver Dockerfiles for testing all the functionality included in this milestone.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"1."),(0,i.kt)("td",{parentName:"tr",align:null},"Substrate module: Aggregate"),(0,i.kt)("td",{parentName:"tr",align:null},"The Aggregate pallet provides the base functionality for implementing the Command Query Responsibility Segregation (CQRS) pattern on a Substrate-based blockchain. It defines the Aggregate trait, which is used to define the state and behavior of an Aggregate.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"2."),(0,i.kt)("td",{parentName:"tr",align:null},"Substrate module: AggregateState"),(0,i.kt)("td",{parentName:"tr",align:null},"The AggregateState pallet provides a default implementation of the AggregateState trait, which stores the current state of an Aggregate in the blockchain's storage. This pallet is responsible for managing the state of an Aggregate and updating it based on incoming commands.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"3."),(0,i.kt)("td",{parentName:"tr",align:null},"Substrate module: AggregateRepository"),(0,i.kt)("td",{parentName:"tr",align:null},"The AggregateRepository pallet provides an implementation of the AggregateRepository trait, which is responsible for retrieving and storing Aggregates in the blockchain's storage. It allows developers to easily store and retrieve Aggregates from the blockchain's storage.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"4."),(0,i.kt)("td",{parentName:"tr",align:null},"Substrate module: CommandDispatcher"),(0,i.kt)("td",{parentName:"tr",align:null},"The CommandDispatcher pallet provides a way to dispatch incoming commands to the appropriate Aggregates based on their type. It uses a HashMap to store the mapping between command types and the Aggregates that handle them.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"5."),(0,i.kt)("td",{parentName:"tr",align:null},"Substrate module: EventStore"),(0,i.kt)("td",{parentName:"tr",align:null},"The EventStore pallet provides a way to store and retrieve events that have been emitted by Aggregates. It allows developers to easily retrieve the events emitted by a specific Aggregate and replay them to reconstruct the current state of the Aggregate.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"6."),(0,i.kt)("td",{parentName:"tr",align:null},"Substrate module: EventsEmitter"),(0,i.kt)("td",{parentName:"tr",align:null},"The EventsEmitter pallet provides a way for Aggregates to emit events. It defines a trait that Aggregates can implement to specify the types of events they emit, and provides a way to subscribe to events emitted by specific Aggregates.")))),(0,i.kt)("h3",{id:"milestone-2--testing-and-documentation"},"Milestone 2 \u2014 Testing and Documentation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Estimated duration:")," 1 month"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"FTE:"),"  2"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Costs:")," 10,000 USD")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"right"},"Number"),(0,i.kt)("th",{parentName:"tr",align:null},"Deliverable"),(0,i.kt)("th",{parentName:"tr",align:null},"Specification"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0a.")),(0,i.kt)("td",{parentName:"tr",align:null},"License"),(0,i.kt)("td",{parentName:"tr",align:null},"Apache 2.0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0b.")),(0,i.kt)("td",{parentName:"tr",align:null},"Documentation"),(0,i.kt)("td",{parentName:"tr",align:null},"We will ensure comprehensive documentation of the code by providing both inline comments and a step-by-step tutorial. This tutorial will guide the user through spinning up a Substrate-based execution environment for the CILA Omnichain Infrastructure and testing omnichain transactions, showcasing the new functionality. Special attention will be given to documenting the setup and testing of multiple Substrate chains running simultaneously, to test the synchronization of the state smart contract between them.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0c.")),(0,i.kt)("td",{parentName:"tr",align:null},"Testing and Testing Guide"),(0,i.kt)("td",{parentName:"tr",align:null},"We will conduct comprehensive unit testing on the core functionalities including Aggregate, Event Store, Aggregate Repository, Snapshot Store, and Dispatcher, to ensure optimum functionality and robustness. In particular, we will place emphasis on testing the infrastructure running with multiple chains to ensure that the synchronization mechanism is functioning as intended. The testing guide will contain instructions on how to execute these tests.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0d.")),(0,i.kt)("td",{parentName:"tr",align:null},"Docker"),(0,i.kt)("td",{parentName:"tr",align:null},"We will deliver Dockerfiles for testing all the functionality included in this milestone, including orchestration with multiple chains. For orchestration purposes we might use Kubernates.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0e."),(0,i.kt)("td",{parentName:"tr",align:null},"Article"),(0,i.kt)("td",{parentName:"tr",align:null},"We will publish a technical article that details the implementation of the Command-Query Responsibility Segregation (CQRS) and Event Sourcing architecture on the Substrate framework. The article will provide an in-depth explanation of the design choices made and the challenges faced during the implementation. It will also include a detailed walkthrough of the codebase, highlighting key areas of interest and how they fit into the overall architecture. The article will be written in a technical language that targets developers with experience in blockchain and distributed systems.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"1."),(0,i.kt)("td",{parentName:"tr",align:null},"Substrate chain"),(0,i.kt)("td",{parentName:"tr",align:null},"Set up and run multiple Substrate chains simultaneously to test the synchronization of a state smart contract between them. This will involve deploying the omnichain smart contract infrastructure to each chain and executing transactions on each chain to ensure that the contract state is properly synchronized between them. Additionally, various network conditions such as network latency and node failures will be simulated to test the robustness and reliability of the synchronization mechanism. The results of these tests will be recorded and analyzed to identify any potential issues and ensure that the synchronization mechanism is functioning as intended.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"2."),(0,i.kt)("td",{parentName:"tr",align:null},"Automated Tests"),(0,i.kt)("td",{parentName:"tr",align:null},"We will create and publish automated tests for critical infrastructure parts of Substrate-based CQRS + Event Sourcing execution enviroment. The aim of this test will be to test two cases - non conflicting execution (changes coming to one chain and transmitted to the other one), and conflicting transactions when the same aggregate is updated with two conflicing state changes that simuntaniusly come to different chans.")))),(0,i.kt)("h3",{id:"milestone-3--example-smart-contracts-and-enhancements"},"Milestone 3 \u2014 Example Smart Contracts and Enhancements"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Estimated duration:")," 1 month"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"FTE:"),"  2"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Costs:")," 10,000 USD")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"right"},"Number"),(0,i.kt)("th",{parentName:"tr",align:null},"Deliverable"),(0,i.kt)("th",{parentName:"tr",align:null},"Specification"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0a.")),(0,i.kt)("td",{parentName:"tr",align:null},"License"),(0,i.kt)("td",{parentName:"tr",align:null},"Apache 2.0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0b.")),(0,i.kt)("td",{parentName:"tr",align:null},"Documentation"),(0,i.kt)("td",{parentName:"tr",align:null},"Provide inline documentation of the NFTAggregate pallet and NFTAggregateState pallet code, as well as a basic tutorial that explains how a user can set up a Substrate node and send test transactions to test the NFT functionalities provided by these modules. Additionally, comprehensive unit tests will be developed and documented to ensure the functionality and robustness of the NFTAggregate pallet and NFTAggregateState pallet. A testing guide will also be provided, describing how to run the tests.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0c.")),(0,i.kt)("td",{parentName:"tr",align:null},"Testing and Testing Guide"),(0,i.kt)("td",{parentName:"tr",align:null},"For this milestone, we will develop comprehensive unit tests to cover the core functions of the NFTAggregate module and the NFTAggregateState pallet. These tests will be designed to ensure the functionality and robustness of the code. The unit tests will be included in the code repository and will cover a range of scenarios to ensure that the code is thoroughly tested. For example, we will test the minting, burning, and transferring of NFTs, as well as error handling and edge cases. In the testing guide, we will provide detailed instructions on how to run these tests, including any required dependencies and setup steps. We will also include information on how to interpret the test results and what to do in the case of failures or errors..")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},(0,i.kt)("strong",{parentName:"td"},"0d.")),(0,i.kt)("td",{parentName:"tr",align:null},"Docker"),(0,i.kt)("td",{parentName:"tr",align:null},"In order to facilitate testing and deployment of the NFTAggregate pallet and NFTAggregateState pallet, we will provide Dockerfiles that can be used to easily set up and configure a development environment. These Dockerfiles will include all the necessary dependencies and configuration to run the Substrate-based blockchain with the new functionalities.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"1."),(0,i.kt)("td",{parentName:"tr",align:null},"Substrate module: NFTAggregate"),(0,i.kt)("td",{parentName:"tr",align:null},"The NFTAggregate pallet provides a way to implement Non-Fungible Tokens (NFTs) on a Substrate-based blockchain. It defines a trait that NFT Aggregates can implement to specify the behavior of NFTs, including minting, burning, and transferring.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"2."),(0,i.kt)("td",{parentName:"tr",align:null},"Substrate module: NFTAggregateState"),(0,i.kt)("td",{parentName:"tr",align:null},"The NFTAggregateState pallet provides a default implementation of the state of an NFT Aggregate, which stores the current state of NFTs in the blockchain's storage. This pallet is responsible for managing the state of NFTs and updating it based on incoming commands.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"3."),(0,i.kt)("td",{parentName:"tr",align:null},"Report: Substrate Ecosystem NFT standards"),(0,i.kt)("td",{parentName:"tr",align:null},"To choose the most optimal standard for omnichain implementation we will conduct research and assess all the available NFT standards against two major criteria: popularity and technical quality. Popularity will be measured by the number of stars on the GitHub repository and how many projects are actually using it (usage assesment will be done on a best effort basis), and the technical quality will be assessed by analyzing if a specific standard satisfies ",(0,i.kt)("a",{parentName:"td",href:"https://en.wikipedia.org/wiki/SOLID"},"SOLID")," design principles.")))),(0,i.kt)("h2",{id:"future-plans"},"Future Plans"),(0,i.kt)("p",null,"In the short term, we plan to continue to develop and enhance our project to ensure its success and sustainability. This will include ongoing testing, bug fixes, and implementing additional features and improvements as needed. We will actively promote our project through various channels, including social media, blog posts, and community events."),(0,i.kt)("p",null,"After the completion of the proposed infrastructure, we intend to continue its development by incorporating support for multiple blockchains and introducing more advanced functionalities, such as dynamic rebalancing for aggregates. Additionally, we plan to establish partnerships with leading players in the Substrate/Polkadot/Kusama ecosystem and to integrate our omnichain infrastructure with existing projects, such as DeFi and NFT marketplaces, to further increase adoption. Finally, we will provide comprehensive documentation and support to ensure that our infrastructure is accessible and user-friendly for developers and users alike."),(0,i.kt)("p",null,"In the long term, we envision our project becoming a leading platform for event-centric CQRS + Event Sourcing execution environments and omnichain smart contracts on the Substrate blockchain. We plan to expand our team and further invest in research and development to stay ahead of the curve and meet the needs of the rapidly evolving blockchain industry. We will continue to engage with the community and seek feedback to ensure that our project remains relevant and valuable to users. Our ultimate goal is to create a platform that is widely adopted and helps to drive the mainstream adoption of blockchain technology."),(0,i.kt)("h2",{id:"additional-information-"},"Additional Information \u2795"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/WZt1hdx.png",alt:"mission"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"How did you hear about the Grants Program?")," personal recommendation"))}c.isMDXComponent=!0}}]);